<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Week 15 Slides</title>
    <meta charset="utf-8" />
    <meta name="author" content="Isabella Velásquez and Maryrose Weatherton" />
    <meta name="date" content="2023-11-27" />
    <script src="week-15-slides_files/header-attrs-2.24/header-attrs.js"></script>
    <link href="week-15-slides_files/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="week-15-slides_files/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <script src="week-15-slides_files/clipboard-2.0.6/clipboard.min.js"></script>
    <link href="week-15-slides_files/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="week-15-slides_files/xaringanExtra-clipboard-0.2.6/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"<i class=\"fa fa-clipboard\"><\/i>","success":"<i class=\"fa fa-check\" style=\"color: #90BE6D\"><\/i>","error":"Press Ctrl+C to Copy"})</script>
    <link href="week-15-slides_files/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
    <link href="week-15-slides_files/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />
    <link href="week-15-slides_files/panelset-0.2.6/panelset.css" rel="stylesheet" />
    <script src="week-15-slides_files/panelset-0.2.6/panelset.js"></script>
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Week 15 Slides
]
.subtitle[
## Final Project Planning
]
.author[
### <strong>Isabella Velásquez and Maryrose Weatherton</strong>
]
.date[
### November 27, 2023
]

---










# Purpose and Agenda

Today, we'll talk about functions -- a reusable blocks of code -- and how we can create our own. You can write a function once and reuse it multiple times in your program. This promotes modularity, making your code easier to understand, maintain, and debug.

Loops enable you to iterate (or loop) over data structures like lists, arrays, or datasets. Loops allow you to execute a block of code repeatedly for automating tasks that involve repetitive operations. This saves time and reduces the chance of errors that can occur with manual repetition.

## What we'll do in this presentation

- Key Concept: Functions
- Key Concept: Loops
- Final projects: Breakout rooms and details

---

## Key Concept: Functions

.panelset[

.panel[.panel-name[Functions]

Functions are reusable blocks of code. When you've used commands like `read_csv()`, `mutate()`, etc... those have all been functions!


```r
read_csv
```

```
## function (file, col_names = TRUE, col_types = NULL, col_select = NULL, 
##     id = NULL, locale = default_locale(), na = c("", "NA"), quoted_na = TRUE, 
##     quote = "\"", comment = "", trim_ws = TRUE, skip = 0, n_max = Inf, 
##     guess_max = min(1000, n_max), name_repair = "unique", num_threads = readr_threads(), 
##     progress = show_progress(), show_col_types = should_show_types(), 
##     skip_empty_rows = TRUE, lazy = should_read_lazy()) 
## {
##     if (edition_first()) {
##         tokenizer &lt;- tokenizer_csv(na = na, quoted_na = quoted_na, 
##             quote = quote, comment = comment, trim_ws = trim_ws, 
##             skip_empty_rows = skip_empty_rows)
##         return(read_delimited(file, tokenizer, col_names = col_names, 
##             col_types = col_types, locale = locale, skip = skip, 
##             skip_empty_rows = skip_empty_rows, comment = comment, 
##             n_max = n_max, guess_max = guess_max, progress = progress, 
##             show_col_types = show_col_types))
##     }
##     if (!missing(quoted_na)) {
##         lifecycle::deprecate_soft("2.0.0", "readr::read_csv(quoted_na = )")
##     }
##     vroom::vroom(file, delim = ",", col_names = col_names, col_types = col_types, 
##         col_select = {
##             {
##                 col_select
##             }
##         }, id = id, .name_repair = name_repair, skip = skip, 
##         n_max = n_max, na = na, quote = quote, comment = comment, 
##         skip_empty_rows = skip_empty_rows, trim_ws = trim_ws, 
##         escape_double = TRUE, escape_backslash = FALSE, locale = locale, 
##         guess_max = guess_max, show_col_types = show_col_types, 
##         progress = progress, altrep = lazy, num_threads = num_threads)
## }
## &lt;bytecode: 0x7fb65240ad78&gt;
## &lt;environment: namespace:readr&gt;
```

]

.panel[.panel-name[Writing a function]

There are three main parts to writing a function:

- Pick a name for the function.
- List the inputs, or arguments, to the function inside function.  The arguments are things that vary across calls.
- You place the code you have developed in body of the function, a `{` block that immediately follows `function(...)`.

```r
name &lt;- function(arguments) {
  body
}
```

]
]

---

.title[Creating Functions]

.panelset[

.panel[.panel-name[Identify repetition]

I write this line of code to optimize PNGs in the posts in my `content/blog' folder.

* Notice each time I use it, the code is very similar. Only the folder name is changing.

```r
xfun::optipng('content/blog/intro-to-quarto')
xfun::optipng('content/blog/what-is-a-function')
xfun::optipng('content/blog/data-science-in-2023')
```

]

.panel[.panel-name[Create function]

```r
png_opt &lt;- function(folder) {
    xfun::optipng(paste0('content/blog/', folder))
}
```

* Name: `png_opt`
* Input: `folder`
* Code: ` xfun::optipng(paste0('content/blog/', folder))`

]

.panel[.panel-name[Use the function]

This will run the equivalent of `xfun::optipng('content/blog/resolutions-2024')`:

```r
png_opt('resolutions-2024')
```

]
]

---

## Function writing exercise

Can you turn these into functions?

```r
mean(is.na(x))
mean(is.na(y))
mean(is.na(z))

x / sum(x, na.rm = TRUE)
y / sum(y, na.rm = TRUE)
z / sum(z, na.rm = TRUE)

round(x / sum(x, na.rm = TRUE) * 100, 1)
round(y / sum(y, na.rm = TRUE) * 100, 1)
round(z / sum(z, na.rm = TRUE) * 100, 1)
```

---

.title[Plot functions]

.panelset[
.panel[.panel-name[Identify repetition]

You can also create functions for ggplot. Let's say you're like me and **really** like `theme_minimal()` and axis labels.

```r
diamonds %&gt;%
    ggplot(aes(x = carat)) +
    geom_histogram(binwidth = 0.1,
                   color = "grey",
                   fill = "blue") +
    theme_minimal() +
    labs(x = "Size (in carats)", y = "Number of diamonds")
```

```r
diamonds %&gt;%
    ggplot(aes(x = carat)) +
    geom_histogram(binwidth = 0.3,
                   color = "white",
                   fill = "green") +
    theme_minimal() +
    labs(x = "Size (in carats)", y = "Number of diamonds")
```

]

.panel[.panel-name[Create a function]

Wouldn’t it be nice if you could wrap this up into a histogram function? 


```r
my_histograms &lt;- function(dat, x, color, fill, binwidth){
    dat %&gt;%
    ggplot(aes(x = x)) +
    geom_histogram(binwidth = binwidth,
               color = color,
               fill = fill) +
    theme_minimal() +
    labs(x = "Size (in carats)", y = "Number of diamonds")
}
```

]

.panel[.panel-name[Use the function]


```r
my_histograms(diamonds, caret, "white", "blue", 0.2)
```

![](week-15-slides_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

]
]

---

# Function style

## Function names

- Ideally, the name of your function will be short, but clearly evoke what the function does.
- Generally, function names should be verbs, and arguments should be nouns.
- Avoid using names that are too generic or easily confused with existing functions or variables.

## Function arguments

- Avoid using too many arguments, as it can make your functions hard to understand and use.
- Use default values when appropriate to provide flexibility.

---

## Function documentation

- Write clean, readable code within your functions. Use consistent indentation, whitespace, and naming conventions.
- `function()` should always be followed by squiggly brackets (`{}`), and the contents should be indented by an additional two spaces.
- Include comments or documentation within your functions to explain their purpose, usage, and any important details.

---

## Key Concept: Loops

.panelset[

.panel[.panel-name[Loops]

Loops allow you to execute a block of code repeatedly. In R, loops are used for iterating over data structures like vectors, lists, or arrays, and performing a specific set of operations on each element.

]

.panel[.panel-name[Writing a loop]

Every for loop has three components:

- You initialize a loop variable (often called an index or counter) to a starting value. This variable keeps track of the current iteration.
- You specify a condition that, as long as it evaluates to true, will continue the loop. The loop runs as long as the condition is true.
-  In each iteration of the loop, the loop variable is updated according to a specified rule. This step controls the progress of the loop.

```r
for (i in 1:5) {
  print(i)
```

]

.panel[.panel-name[Writing a loop]

```r
for (i in 1:5) {
  print(i)
```
- `i` is the loop variable, starting at 1.
- The condition is `i &lt;= 5`, which means the loop will run as long as `i` is less than or equal to 5.
- In each iteration, `i` is incremented by 1 (`i = i + 1`), and the value of `i` is printed.

]
]

---

## Difference between loops and functions

Loops are used for repeating tasks, while functions are used for encapsulating and reusing code to perform specific operations.

.panelset[

.panel[.panel-name[Purpose]

- Loops are used for repetition and iterating over data.
- Functions are used for encapsulating and reusing specific pieces of code.
]

.panel[.panel-name[Use]

- Loops repeat a block of code until a certain condition is met.
- Functions execute a specific task or operation when called.
]

.panel[.panel-name[Structure]

- Loops consist of control structures like for, while, etc.
- Functions are modular and self-contained with their own logic.
]

.panel[.panel-name[Input/Output]

- Loops typically don't have explicit inputs and outputs but operate on variables defined outside the loop.
- Functions explicitly take input parameters and often return values as output.
]

.panel[.panel-name[Reuseability]

- Loops are used to repeat a sequence of instructions in one place.
- Functions are designed for reuse across different parts of a program.

]
] 
---

## Key Concept: Loops

.panelset[

.panel[.panel-name[Repeat a block of code]

```r
my_histograms(diamonds, caret, "white", "blue", 0.2)
my_histograms(diamonds, caret, "white", "green", 0.2)
my_histograms(diamonds, caret, "white", "red", 0.2)
```

]

.panel[.panel-name[Create a loop]

You can use a for loop in R to iterate over the colors and call the `my_histograms()` function with each color from the colors vector:

- Define a vector colors that contains the colors you want to use: "blue", "green", and "red."
- Use a for loop to iterate over each element (color) in the colors vector.
- Inside the loop, call the `my_histograms()` function with the specified arguments, including the current color from the loop iteration.

This loop will call `my_histograms()` three times, once for each color in the colors vector, achieving the same result as the original three function calls.


```r
colors &lt;- c("blue", "green", "red")

for (color in colors) {
  my_histograms(diamonds, caret, "white", color, 0.2)
}
```

]
]
---

## The purrr package

Purrr is a package in R that provides a collection of functions for working with functions and vectors.

- Instead of using explicit loops, purrr introduces the concept of "mapping" a function over a data structure where you apply a function to each element of a vector or list without writing a loop.

---

## The purrr package

In purrr, you can achieve the same result as the for loop by using the `map()` function to iterate over the colors vector and call the `my_histograms()` function for each color.

* Use the `map()` function from the purrr package.
* The first argument to `map()` is the vector colors that you want to iterate over.
* The second argument to `map()` is a formula (`~`) that specifies how to call the `my_histograms()` function for each color.
* `.x` represents the current element (color) in the iteration.
* The result of `map()` is a list containing the results of calling `my_histograms()` for each color.


```r
library(purrr)

colors &lt;- c("blue", "green", "red")

map(colors, ~ my_histograms(diamonds, caret, "white", .x, 0.2))
```

```
## [[1]]
```

![](week-15-slides_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;

```
## 
## [[2]]
```

![](week-15-slides_files/figure-html/unnamed-chunk-6-2.png)&lt;!-- --&gt;

```
## 
## [[3]]
```

![](week-15-slides_files/figure-html/unnamed-chunk-6-3.png)&lt;!-- --&gt;

---

## Exercise

Calculate the square of each number in a list.

Given a list: `numbers &lt;- list(1, 2, 3, 4, 5)`

Write a purrr sequence that `prints()` the squared number `x^2`.

---

## Final project presentations

.panelset[
.panel[.panel-name[Presentation]

Please prepare a 5-7 minute presentation on your project describing

- The topic of your project
- Why you chose this topic
- What problem it solved or question it helped/helps you to answer
- What you did, including the learning/independent work you had to do to be able to achieve what you did
- What you are most proud of about your final project
- What you still want to know more about/what you want to do next having completed your final project

We'll have folks go alphabetically.

]

.panel[.panel-name[Presentation rubric]

- 6 points addressed: 75 points
- Presentation neatly organized and presented in an understandable manner: 20 points
- Within time limits: 5 points

]

.panel[.panel-name[Feedback]

- If you have questions to pose to others, please come with them!
- Everybody, please be prepared to give feedback to the presenters.
- The final sumbmission a week later should incorporate feedback from the presentation.
]
]

---

## Final project breakout rooms

- Briefly introduce your project
- Any questions or issues that your classmates can help with?
- Try to identify one part of your project that could be transformed into a function or a loop and discuss how you'd do it to your group. Work on this for the remainder of the time.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create();
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
